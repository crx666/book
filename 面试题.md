​								面试题

###    go基础知识

1. 数组通过函数传参，在函数中修改了数组值，那函数外部的数组会被修改吗？

​	会，数组传参是值拷贝，不是引用传参

2. 切片的长度和容量有什么区别
3. 从数组生成了一个切片，修改了切片的值，数组的值会变化吗？

​	分为两种情况，如果切片的容量改变了，那么不会改变 ，如果切片的容量没有变化，那么旧数组会改变

4. 切片的扩容机制

​	容量小于1024，扩容为原来的2倍，大于1024，扩容为原来的1.25倍

5. 切片函数传参，在函数中修改了切片的值，那么外部切片的值会改变吗？

​	如果函数里的切片容量变化了，那么外部切片不会变化，反之变化

6. ```go

   1. a := []int{1,2,3,4,5}

   b := a[1:4]

   b = append(b,0)

   由于b添加0的时候没有执行扩容操作，并且b的容量为5-1=4，但是b只有3个值，容量还有空余，那么b添加0会直接修改到a，所有5被修改为0
   ```



7. 简单说说map的底层实现

8. 哈希的等量扩容和增量扩容是什么？

   增量扩容是新建一个bucket，长度是原来的2倍，把旧bucket数据搬迁到新bucket，缓慢搬迁，访问一次map搬迁2个键值对，直到搬迁完毕，删除old buckets

   等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。

9. 简单说说go语言的锁

10. 什么是锁的自旋

    加锁时，如果当前Locked位为1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续的探测Locked位是否变为0，这个过程即为自旋过程。

    自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，更充分的利用CPU，尽量避免协程切换

11. 什么是锁的饥饿模式

    如果自旋模式一直抢占到锁，但是别的协程就会一直处于等待状态，如果阻塞等待时长超过1ms，那么就进入饥饿状态，之后就不会进入自旋模式，所有的协程都有机会拿到锁。

12. channel的使用

    管道关闭，管道缓冲区还有数据，仍然可以读取到数据

    panic出现的常见场景还有：

    1. 关闭值为nil的channel
    2. 关闭已经被关闭的channel
    3. 向已经关闭的channel写数据

13. go的gc模式

14. 三色标记法和python的引用计数法

    引用计数可能导致内存泄漏，互相引用

15. go的gmp



# mysql

1. 索引有哪几种

2. 联合索引匹配逻辑和失效逻辑

3. b树和b+树的区别

   - **B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。**
   - **B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；**
   - **B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。**

4. 索引失效的情况有哪些

   - 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效，使用`like xx%`可以使用索引；
   - 当我们在查询条件中对索引列使用函数，就会导致索引失效。
   - 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
   - **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
   - 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
   - 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

5. 事务隔离级别

   读未提交、读提交、可重复读、串行

   默认是可重复读